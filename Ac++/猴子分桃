/********
秋天到了，n只猴子采摘了一大堆苹果放到山洞里，约定第二天平分。这些猴子很崇拜猴王孙悟空，所以都想给他留一些苹果。第一只猴子悄悄来到山洞，把苹果平均分成n份，把剩下的m个苹果吃了,然后藏起来一份，最后把剩下的苹果重新合在一起。这些猴子依次悄悄来到山洞，都做同样的操作，恰好每次都剩下了m个苹果。第二天，这些猴子来到山洞，把剩下的苹果分成n分，巧了，还是剩下了m个。问，原来这些猴子至少采了多少个苹果。

此题类似李政道教授的那道猴子分桃算术题,用巧解的方法果然高效美妙。
可设苹果总数为x,往总数里加(n-1)*m个苹果使y=x + (n-1)*m;
第一只猴子吃m个苹果再藏(x-m)*(1/n)个,即第一只猴子共拿了y*(1/n)个苹果,苹果剩(n-1)/n *y,
...可以依此类推,最后苹果剩n*一个整数再加m个。( 自己动手动脑丰衣足食:) ,可以假设加一只猴子)
得出公式: X = (n^n+1)-((n- 1)* m)
但由于OJ第一一个测试数据出错,第二 天猴子们把苹果分成n份时, 一-份至少1个,所以本题题解不是百分之百正确。
更正后公式应为: x=k(n^n+1)-((n- 1)* m)更正后题解

********/
#include<iostream>
#include<math.h>
using namespace std;
int main() {
  int n, m;
  cin >> n >> m;
  long long sum= pow(n, n + 1) - (n - 1) * m;
  cout<<sum;
  return 0;
}
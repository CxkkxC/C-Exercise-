#include<iomanip>
#include<iostream>
using namespace std;
int main()
{
	cout<<"降阶法计算三阶四阶五阶行列式，得出三阶转置丶伴随矩阵与逆矩阵。"<<endl;
	while(1)
	{
int i,j;
cout<<"请输入矩阵的行数和列数:";
cout<<'\n'<<"行数为:";
cin>>i;
cout<<"列数为:";
cin>>j;
if(i*j!=9 && i*j!=16 && i*j!=25)
{
cout<<"对不起，只能计算三四五阶行列式，你的输入有误！"<<endl; break;
}
int a,b;
int ** m=new int*[i];
//int *m[i];
//预先定义一个指针数组m,用于保存i个一维数组的首地址。
for(a=0; a<i; a++)
//使用循环结构，为每行动态分配一个一维数组。
 {
m[a]=new int[j];
//动态分配一维数组，元素个数应等于二维数组的列数j。
}
//赋值过程
for(a=0;a<i;a++)
for(b=0;b<j;b++)
{
cout<<"请输入数组a["<<a<<"]["<<b<<"]的值:";
cin>>m[a][b];
cout<<endl;
}
//显示过程
cout<<"输入的这个矩阵为："<<endl;
for(a=0;a<i;a++)//行
{
for(b=0;b<j;b++)//列
{
	cout<<m[a][b]<<" ";
	}
cout<<endl;
}
/*计算三阶四阶行列式，流沙法计算三阶行列式，按第三列展开计算四阶行列式*/
if(i*j==9)
{
int a1,a2;
float D=0;
a1=m[0][0] * m[1][1] * m[2][2]+m[0][1]* m[1][2]* m[2][0]+m[0][2] * m[1][0] * m[2][1];
a2=m[0][2] * m[1][1] * m[2][0]+m[0][0]* m[1][2]* m[2][1]+m[0][1] * m[1][0] * m[2][2];
D=a1-a2;
cout<<"这个三阶行列式的值为："<<"|A|或者是D = "<<D<<endl;
	int t[3][3];
for(int n=0;n<i;n++)
{
for(int M=0;M<j;M++)
{ 
t[M][n]=m[n][M];
}
}
cout<<endl;
cout<<"这个转置后的矩阵A^T为："<<endl;
for(int c=0;c<j;c++)
{
for(int d=0;d<i;d++)
{
cout<<t[c][d]<<" ";
}
cout<<endl;
}
cout<<"这个矩阵的伴随矩阵A*为："<<endl;
float A11,A12,A13,A21,A22,A23,A31,A32,A33;
    A11=m[1][1]*m[2][2]-m[1][2]*m[2][1];
	A12=-(m[1][0]*m[2][2]-m[1][2]*m[2][0]);
	A13=m[1][0]*m[2][1]-m[1][1]*m[2][0];
	A21=-(m[0][1]*m[2][2]-m[0][2]*m[2][1]);
	A22=m[0][0]*m[2][2]-m[0][2]*m[2][0];
	A23=-(m[0][0]*m[2][1]-m[0][1]*m[2][0]);
	A31=m[0][1]*m[1][2]-m[0][2]*m[1][1];
	A32=-(m[0][0]*m[1][2]-m[0][2]*m[1][0]);
	A33=m[0][0]*m[1][1]-m[0][1]*m[1][0];
	m[0][0]=A11;
	m[0][1]=A21;
	m[0][2]=A31;
	m[1][0]=A12;
	m[1][1]=A22;
	m[1][2]=A32;
	m[2][0]=A13;
	m[2][1]=A23;
	m[2][2]=A33;
	for (int g=0;g<3;g++)
	{
		for (int s=0;s<3;s++)
	{
		cout<<m[g][s]<<" ";
		}
		cout<<endl;
		}
	cout<<endl;
float A1=0,A2=0,A3=0,A4=0,A5=0,A6=0,A7=0,A8=0,A9=0;
	A1=1/D*A11;
	A2=1/D*A21;
	A3=1/D*A31;
A4=1/D*A12;
A5=1/D*A22;
A6=1/D*A32;
A7=1/D*A13;
A8=1/D*A23;
A9=1/D*A33;
float o[3][3]={{A1,A2,A3},{A4,A5,A6},{A7,A8,A9}};
cout<<"这个矩阵的逆矩阵A^-1为："<<endl;
	for (int w=0;w<3;w++)
	{
		for (int f=0;f<3;f++)
	{
		cout<<setiosflags(ios::fixed)<<setprecision(1);
		//需要保存的小数位数
		cout<<o[w][f]<<" ";
		}
		cout<<endl;
		}
	cout<<endl;
}
else if(i*j==16)
{
	int A13,A23,A33,A43,D1=0;
	A13=m[1][0] * m[2][1] * m[3][3]+m[1][1]* m[2][3]* m[3][0]+m[1][3] * m[2][0] * m[3][1]-m[1][3] * m[2][1] * m[3][0]-m[1][0]* m[2][3]* m[3][1]-m[1][1] * m[2][0] * m[3][3];
	A23=-(m[0][0] * m[2][1] * m[3][3]+m[0][1]* m[2][3]* m[3][0]+m[0][3] * m[2][0] * m[3][1]-m[0][3] * m[2][1] * m[3][0]-m[0][0]* m[2][3]* m[3][1]-m[0][1] * m[2][0] * m[3][3]);
	A33=m[0][0] * m[1][1] * m[3][3]+m[0][1]* m[1][3]* m[3][0]+m[0][3] * m[1][0] * m[3][1]-m[0][3] * m[1][1] * m[3][0]-m[0][0]* m[1][3]* m[3][1]-m[0][1] * m[1][0] * m[3][3];
	A43=-(m[0][0] * m[1][1] * m[2][3]+m[0][1]* m[1][3]* m[2][0]+m[0][3] * m[1][0] * m[2][1]-m[0][3] * m[1][1] * m[2][0]-m[0][0]* m[1][3]* m[2][1]-m[0][1] * m[1][0] * m[2][3]); D1=(m[0][2]*A13)+(m[1][2]*A23)+(m[2][2]*A33)+(m[3][2]*A43);
	cout<<"这个四阶行列式的值为："<<"D ="<<D1<<endl;
}
}
system("pause");           

return 0;
}
